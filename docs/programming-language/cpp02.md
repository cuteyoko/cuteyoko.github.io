# 从零开始c++: 从代码到汇编

## 例程

```
#include <iostream>
  
using namespace std;

int add(const int a, const int b)
{
        return a + b;
}

int main()
{
    int ret = add(3, 6);
    cout << ret << endl;
    return ret;
}
```

### 反汇编解析

```asm
0000000000000000 <_Z3addii>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   89 7d fc                mov    %edi,-0x4(%rbp)
   b:   89 75 f8                mov    %esi,-0x8(%rbp)
   e:   8b 55 fc                mov    -0x4(%rbp),%edx
  11:   8b 45 f8                mov    -0x8(%rbp),%eax
  14:   01 d0                   add    %edx,%eax
  16:   5d                      pop    %rbp
  17:   c3                      retq


0000000000000018 <main>:
  18:   f3 0f 1e fa             endbr64
  1c:   55                      push   %rbp
  1d:   48 89 e5                mov    %rsp,%rbp
  20:   48 83 ec 10             sub    $0x10,%rsp
  24:   be 06 00 00 00          mov    $0x6,%esi
  29:   bf 03 00 00 00          mov    $0x3,%edi
  2e:   e8 00 00 00 00          callq  33 <main+0x1b>
  33:   89 45 fc                mov    %eax,-0x4(%rbp)
  36:   8b 45 fc                mov    -0x4(%rbp),%eax
  39:   89 c6                   mov    %eax,%esi
  3b:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 42 <main+0x2a>
  42:   e8 00 00 00 00          callq  47 <main+0x2f>
  47:   48 89 c2                mov    %rax,%rdx
  4a:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 51 <main+0x39>
  51:   48 89 c6                mov    %rax,%rsi
  54:   48 89 d7                mov    %rdx,%rdi
  57:   e8 00 00 00 00          callq  5c <main+0x44>
  5c:   8b 45 fc                mov    -0x4(%rbp),%eax
  5f:   c9                      leaveq
  60:   c3                      retq

```

### gdb流程解析

```asm
=> 0x00005555555551c1 <+0>:	endbr64 
   0x00005555555551c5 <+4>:	push   %rbp
   0x00005555555551c6 <+5>:	mov    %rsp,%rbp
   0x00005555555551c9 <+8>:	sub    $0x10,%rsp
   0x00005555555551cd <+12>:	mov    $0x6,%esi
   0x00005555555551d2 <+17>:	mov    $0x3,%edi
   0x00005555555551d7 <+22>:	callq  0x5555555551a9 <add(int, int)>
   0x00005555555551dc <+27>:	mov    %eax,-0x4(%rbp)
   0x00005555555551df <+30>:	mov    -0x4(%rbp),%eax
   0x00005555555551e2 <+33>:	mov    %eax,%esi
   0x00005555555551e4 <+35>:	lea    0x2e55(%rip),%rdi        # 0x555555558040 <_ZSt4cout@@GLIBCXX_3.4>
   0x00005555555551eb <+42>:	callq  0x5555555550b0 <_ZNSolsEi@plt>
   0x00005555555551f0 <+47>:	mov    %rax,%rdx
   0x00005555555551f3 <+50>:	mov    0x2dd6(%rip),%rax        # 0x555555557fd0
   0x00005555555551fa <+57>:	mov    %rax,%rsi
   0x00005555555551fd <+60>:	mov    %rdx,%rdi
   0x0000555555555200 <+63>:	callq  0x555555555090 <_ZNSolsEPFRSoS_E@plt>
   0x0000555555555205 <+68>:	mov    -0x4(%rbp),%eax
   0x0000555555555208 <+71>:	leaveq 
   0x0000555555555209 <+72>:	retq
```

进入main函数时打印寄存器如下：

```asm
(gdb) i reg
rax            0x5555555551c1      93824992235969
rbx            0x555555555270      93824992236144
rcx            0x100               256
rdx            0x7fffffffe4e8      140737488348392
rsi            0x7fffffffe4d8      140737488348376
rdi            0x1                 1
rbp            0x0                 0x0
rsp            0x7fffffffe3e8      0x7fffffffe3e8
r8             0x0                 0
r9             0x7ffff7eabec0      140737352744640
r10            0x7ffff7d2f1d5      140737351184853
r11            0x7ffff7e22940      140737352182080
r12            0x5555555550c0      93824992235712
r13            0x7fffffffe4d0      140737488348368
r14            0x0                 0
r15            0x0                 0
rip            0x5555555551c1      0x5555555551c1 <main()>
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
```

逐步执行
```
(gdb)nexti
(gdb)disassemble
...
=> 0x00005555555551c5 <+4>:	push   %rbp
...
(gdb) i reg
...
rip            0x5555555551c5      0x5555555551c5 <main()+4> ## 这里可以观察到ip指令寄存器转移到下一个指令。
...
```

逐步执行
```asm
(gdb) nexti
=> 0x00005555555551c6 <+5>:	mov    %rsp,%rbp
(gdb) i reg
...
rsp            0x7fffffffe3e0      0x7fffffffe3e0 ## 可以看到堆栈指针发生了变化（-8，这是由于rbp push入栈所致）
...
rip            0x5555555551c6      0x5555555551c6 <main()+5> ## 又加了一步，以后这个就不再赘述了

# 由于上面堆栈发生了变化，指令本质是push %rbp, rbp由上可以看到是0
(gdb) x/24xb 0x7fffffffe3e8-0x10
0x7fffffffe3d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3e0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00 # ==》这里可以看到数据填充为0了。
0x7fffffffe3e8:	0xb3	0xe0	0xb0	0xf7	0xff	0x7f	0x00	0x00

## 继续
   0x00005555555551c6 <+5>:	mov    %rsp,%rbp
=> 0x00005555555551c9 <+8>:	sub    $0x10,%rsp

rbp            0x7fffffffe3e0      0x7fffffffe3e0  =》这里将rsp的值放入了rbp,其他堆栈之类无变化
rsp            0x7fffffffe3e0      0x7fffffffe3e0

## 继续
   0x00005555555551c9 <+8>:	sub    $0x10,%rsp
=> 0x00005555555551cd <+12>:	mov    $0x6,%esi

rsp            0x7fffffffe3d0      0x7fffffffe3d0 # 由于减法操作，将堆栈指针移动了16字节（两个变量的大小） 大概是准备调用的一些空间
eflags         0x202               [ IF ] # 由于减法操作，改动了一些flag

## 继续
   0x00005555555551cd <+12>:	mov    $0x6,%esi
=> 0x00005555555551d2 <+17>:	mov    $0x3,%edi

# 寄存器 esi变为 6 // 参数
rsi            0x6                 6

## 继续
   0x00005555555551d2 <+17>:	mov    $0x3,%edi
=> 0x00005555555551d7 <+22>:	callq  0x5555555551a9 <add(int, int)>
rsi            0x6                 6
rdi            0x3                 3

## 继续

进入调用阶段
(gdb) disassemble 
Dump of assembler code for function add(int, int):
=> 0x00005555555551a9 <+0>:	endbr64 

rsp            0x7fffffffe3c8      0x7fffffffe3c8 ## 调用导致
rip            0x5555555551a9      0x5555555551a9 <add(int, int)> # =》这里可以看到指令指针到了调用函数起始位置

堆栈变化如下：
0x7fffffffe3c8:	0xdc	0x51	0x55	0x55	0x55	0x55	0x00	0x00 # =》要返回的执行位置。这里可以看到 由于callq指令，需要执行的下一句语句被入栈了,返回时，这个值会赋给rip
0x7fffffffe3d0:	0xd0	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00 # =》？？？
0x7fffffffe3d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00 # =》被跳过
0x7fffffffe3e0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00 # =》被跳过

## 继续
   0x00005555555551a9 <+0>:	endbr64 
   0x00005555555551ad <+4>:	push   %rbp
   0x00005555555551ae <+5>:	mov    %rsp,%rbp
=> 0x00005555555551b1 <+8>:	mov    %edi,-0x4(%rbp)

这里省略了两步，一个是放入堆栈，要给是 将rsp 给rbp,操作结果如下
rbp            0x7fffffffe3c0      0x7fffffffe3c0
rsp            0x7fffffffe3c0      0x7fffffffe3c0

## 继续
   0x00005555555551a9 <+0>:	endbr64 
   0x00005555555551ad <+4>:	push   %rbp
   0x00005555555551ae <+5>:	mov    %rsp,%rbp
   0x00005555555551b1 <+8>:	mov    %edi,-0x4(%rbp)
=> 0x00005555555551b4 <+11>:	mov    %esi,-0x8(%rbp)

这里将edi的值放入堆栈
0x7fffffffe3a0:	0x02	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3a8:	0xbd	0x52	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3b0:	0xc8	0x7f	0xcd	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe3b8:	0x70	0x52	0x55	0x55 [0x03	0x00	0x00	0x00] # =》这个地方的值被改成3，
0x7fffffffe3c0:	0xe0	0xe3	0xff	0xff	0xff	0x7f	0x00	0x00 ## 原先的ebp
0x7fffffffe3c8:	0xdc	0x51	0x55	0x55	0x55	0x55	0x00	0x00 ## 要返回的执行位置
0x7fffffffe3d0:	0xd0	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00 ## ???
0x7fffffffe3d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00

0x7fffffffe3a0:	0x02	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3a8:	0xbd	0x52	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3b0:	0xc8	0x7f	0xcd	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe3b8:[0x06	0x00	0x00	0x00] 0x03	0x00	0x00	0x00 # => 赋值为6
0x7fffffffe3c0:	0xe0	0xe3	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3c8:	0xdc	0x51	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3d0:	0xd0	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00

## 执行加法
   0x00005555555551b7 <+14>:	mov    -0x4(%rbp),%edx
   0x00005555555551ba <+17>:	mov    -0x8(%rbp),%eax
这几个就不看执行过程了，将值取到寄存器中，
rax            0x6                 6
rdx            0x3                 3
   0x00005555555551bd <+20>:	add    %edx,%eax
rax            0x9                 9

=> 0x00005555555551bf <+22>:	pop    %rbp
rbp            0x7fffffffe3e0      0x7fffffffe3e0
rsp            0x7fffffffe3c8      0x7fffffffe3c8

0x00005555555551c0 <+23>:	retq
rsp            0x7fffffffe3d0      0x7fffffffe3d0
rip            0x5555555551dc      0x5555555551dc <main()+27>

## 相关堆栈
0x7fffffffe380:	0x20	0xfa	0xfb	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe388:	0xff	0xff	0x00	0x00	0x01	0x00	0x00	0x00
0x7fffffffe390:	0xa0	0xe3	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe398:	0x6e	0x52	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3a0:	0x02	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3a8:	0xbd	0x52	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3b0:	0xc8	0x7f	0xcd	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe3b8:	0x06	0x00	0x00	0x00	0x03	0x00	0x00	0x00 [3 + 6]
0x7fffffffe3c0:	0xe0	0xe3	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3c8:	0xdc	0x51	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3d0:	0xd0	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3e0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3e8:	0xb3	0xe0	0xb0	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe3f0:	0x20	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3f8:	0xd8	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00

0x7fffffffe380:	0x20	0xfa	0xfb	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe388:	0xff	0xff	0x00	0x00	0x01	0x00	0x00	0x00
0x7fffffffe390:	0xa0	0xe3	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe398:	0x6e	0x52	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3a0:	0x02	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3a8:	0xbd	0x52	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3b0:	0xc8	0x7f	0xcd	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe3b8:	0x06	0x00	0x00	0x00	0x03	0x00	0x00	0x00
0x7fffffffe3c0:	0xe0	0xe3	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3c8:	0xdc	0x51	0x55	0x55	0x55	0x55	0x00	0x00
0x7fffffffe3d0:	0xd0	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3d8:	0x00	0x00	0x00	0x00 [0x09	0x00	0x00	0x00] ## 这里把返回值放到了栈变量中
0x7fffffffe3e0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x7fffffffe3e8:	0xb3	0xe0	0xb0	0xf7	0xff	0x7f	0x00	0x00
0x7fffffffe3f0:	0x20	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00
0x7fffffffe3f8:	0xd8	0xe4	0xff	0xff	0xff	0x7f	0x00	0x00

至此一个调用基本完结。后续可以看一些比较大的返回值是怎么处理的（比如结构体）。
触类旁通，比较容易解决。

```


