---
title: CMake一纸综合
description: 如题
categories:
 - 技能
tags:
 - CMAKE
---



## cmake哲学

> CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles and workspaces that can be used in the compiler environment of your choice. The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment for open-source projects such as ITK and VTK.

一言以避之，CMake是用以实现跨平台软件构建/测试/打包的软件，构建是其主要功能，所谓构建即将材料通过某些步骤生成想要的目标。

### make

说起构建就不得不谈make. make解读Makefile后，按照目标+依赖+动作的形式来组织构建过程。一个经典的编写方法如下:

```makefile
.PHONY all watch_tv
all: watch_tv # all I want is watching tv
    XXX # no step Needed
money=xxx
watch_tv : tv sofa # need tv and sofa
    sit down and watch

tv : money
    buy tv and send to home

sofa : money
    buy sofa and send to home
```

makefile本质是一种“备好材料，缺少组件就去看这种组件如何生成，待备好资源就按步骤达成目标”的描述方法，是一种递归式的做事方法。

### cmake

makefile的这种做事方法足够实用，问题是，事无巨细必须清楚描述其步骤。如果子目标之间完全无相同，那么万事大吉，无限细分即可。然则步骤不断增多时，维护这些步骤时便容易出错。同时，如果把做事方法局限到一件事一种语言上，很多规则本来就在哪里，不必要单独编写，也不需要个人去决定所有，毕竟人无完人难免出错。这有点像架构师，他能够构想一套可以应用的架构，在某个地方应用某个特性，他了解特性会做什么，但不了解如何去完美得实现这个特性。

cmake应运而生,cmake是`Cross platform Make`的意思,简单来看像分离了c/c++一些既定语法以及某些平台构建规则及特性的构建工具。你只需要关心依赖，然后最后构建时，指定所需要的特性/平台即可，这将原先的工作分为两个部分，一是指定工具，二是指定依赖材料及步骤，把工具相关的实现细节从步骤里剥离出来。好了，跨平台的目的达成了。

## cmake实践

新时代了，这次要讲的话题必是ModernCMake.基本是基于cmake 3以后的版本，有点类似python2和python3，但至少向前兼容了。

### modern cmake 哲学

在modernCMake看来，一切以object + object property的方式来展现。

### modern cmake 最佳实践
严格来说，很多最佳实践都不是最佳，但起码是上佳实践了，毕竟这是哲学和取舍的事（而且影响不足以大到不能接受）。

#### do & not

[see this](https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1)
翻译：

**概述**
1. 使用至少cmake 3.0.0以上版本：因为cmake从3.0.0支持modern cmake
2. CMake Is Code(CIC=v=)
3. Project properties 全局定义，放置于顶层目录。
4. 禁止使用`add_compile_options, include_directories, link_directories, link_libraries`等等，我们是modern cmake了，跟上ok？
5. 不要用自己知道的语法来设置`CMAKE_CXX_FLAGS`, 你直接告诉CMake做什么，而不是怎么做，怎么做是CMake的事情，不同平台设置FLAG的语法不同，格式也不同，cmake在这方面比你更专业。
6. 不要滥用`usage requirements`: 比如，在target_compile_options的PUBLIC/INTERFACE段使用`-Wall`, 不需要。

**Module**
1. Use modern find modules that declare exported targets.（待详述）
2. Use exported targets of external packages.
3. Use a find module for third-party libraries that do not support clients to use CMake.
4. Report it as a bug to third-party library authors if a library does not support clients to use CMake. If the library is an open-source project, consider sending a patch.(霸道哦）
5. Write a find module for third-party libraries that do not support clients to use CMake.（没有就自己造）
6. Export your library’s interface, if you are a library author. [see this](https://youtu.be/bsXLMQ6WgIk?t=37m15s)

**Project**
1. 避免自定义变量:诸如`add_library(libx ${VAR1} ${VAR2})` 应为`add_library(libx a.h b.cpp)`
2. 忘了`file(GLOB)`吧：这会导致make系统不能了解文件发生了哪些变化——GLOB会把文件生成一个文件列表，交给编译系统。而由于并不是所有构建工具都支持GLOB，所以，cmake必须把这个展开变量的工作自己包揽，而不是直接交给编译系统。当然，不用这个反而比较安全和可控。如果你一个目录大到无法人工管理，建议还是进行控制。
3. Put CI-specific settings in CTest scripts, not in the project. 纯粹一点。
4. Follow a naming convention for test names. 如果使用这个test就遵守他的规则。

**Targets and Properties**
1. 以target & properties的想法来构建。
2. 以对象的方式来理解：构造函数`add_executable` `add_library` 成员变量`target properties`(当然也不适宜直接改动啦) 成员方法`target_compile_definitions` `target_compile_features`  `target_compile_options` `target_include_directories` `target_link_libraries` `get_target_property` `set_target_property`
3. Internal properties keep `PRIVATE`
> If a target needs properties internally (i.e., compile definitions, compile options, compile features, include directories, and library dependencies), add them to the PRIVATE section of the target_* commands.
4. 用`target_compile_definitions`来指定编译选项
5. `target_compile_features`指定编译feature
6. `target_include_directories` `target_link_libraries`
7. `target_include_directories` 不要包含组件外的目录
8. 明确指定`PUBLIC PRIVATE INTERFACE`
9. 不要用target_compile_options来设置影响abi的选项：-> define compile options globally
10. Using a library defined in the same CMake tree should look the same as using an external library.

**Func&Macro**
1. 用函数而不是宏。
2. Use macros for defining very small bits of functionality only or to wrap commands that have output parameters. Otherwise create a function.
3. Don’t use macros that affect all targets in a directory tree, like include_directories, add_definitions, or link_libraries

**Argument**
1. Use cmake_parse_arguments as the recommended way to handle complex argument-based behaviors or optional arguments in any function.不要重复造轮子

**LOOPS**
1. Use modern foreach syntax.

**Packages**
1. Use CPack to create packages.
2. Write a CPackConfig.cmake that includes the one generated by CMake.

**Cross Compiling**
1. Use toolchain files for cross compiling.
2. Keep toolchain files simple.

**Warnings and Errors**
1. Treat build errors correctly.
2. Treat warnings as errors.：
> To treat warnings as errors, never pass -Werror to the compiler. If you do, the compiler treats warnings as errors. You can no longer treat warnings as errors, because you no longer get any warnings. All you get is errors.
3. Treat new warnings as errors.

**Static Analysis**
1. Use more than one supported analyzer.

2. For each header file, there must be an associated source file that #includes the header file at the top, even if that source file would otherwise be empty.：静态分析可能只从.cpp文件开始


